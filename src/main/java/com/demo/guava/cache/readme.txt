Guava Cache的适用场景
Cache（缓存）在很广泛的场景下都是很有用的。比如，当一个值的计算或者检索的代价很大，并且在稍后的特定输入发生后，你将不止一次的需要这个值的时候，就应当考虑使用Cache了。
Cache是和ConcurrentMap很相像的东西。最本质的不同就是，ConcurrentMap持有所有被添加进的元素，直到它们专门被移除。从另一方面来说，为了使得内存的使用可控，Cache通常来说是可配置来自动回收元素的。在一些情况下，即使LoadingCache也会很有用，虽然由于他的自动缓存加载机制，它不回收元素。
通常，Guava Cache组件在下面的场景中适用：

你想花费一些内存来提高速度。
你预期到一些key的值将被不止一次地被查询。
你的缓存将不会需要比内存能够存储的数据更多。（Guava Cache对于一个单独运行的应用来说是本地的。它们不回将数据存储在文件中或者外部服务器上。如果这不适合你的需求，那么考虑使用其它的工具，比如Memcached）

如果上面的这些都符合你的需要，那么Guava Cache组件将适合你！
获得一个Cache是使用CacheBuilder来完成的。
注意：如果你不需要Cache的一些特性，那么ConcurrentHashMap是更加有内存效率的－－但是使用任何旧的ConcurrentMap都会很难或者几乎不可能去完成Cache所支持的一些特性。
Guava Cache的使用示例
使用缓存时，最常遇到的场景需要就是：

"获取缓存-如果没有-则计算"[get-if-absent-compute]的原子语义.

具体含义：

从缓存中取。
缓存中存在该数据，直接返回；
缓存中不存在该数据，从数据源中取。
数据源中存在该数据，放入缓存，并返回；
数据源中不存在该数据，返回空。

Dao.java这段代码实现了一个做在DAO层的本地缓存。其中，getPOIList()是对外提供的方法，该方法中实现了上述逻辑。getPOIListFromDB()是用于模拟从数据库中取数据的方法。

为什么要把Cache对象放在DAO层？
思考一下Cache的用途，能够想到在一个Application中，对同一种对象的缓存只需要一个就够了。比如示例中的poiCache是缓存city对应的poi信息的，那么在这个Application中最好只存在一个poiCache。
实现这样的要求有以下几种方式：

Spring的Singleton模式（推荐）
比较常见的做法是将Server和DAO都作为单例的bean交给Spring容器管理，而将缓存放在DAO层不但实现了单例，也更合理（数据的缓存策略本身就应是数据访问层的一部分）。
静态初始化（不推荐）

