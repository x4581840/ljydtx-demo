1. Cloneable的用途
Cloneable是标记型的接口，它们内部都没有方法和属性，实现 Cloneable来表示该对象能被克隆，
能使用Object.clone()方法。如果没有实现 Cloneable的类对象调用clone()就会抛出CloneNotSupportedException。
2. 克隆的分类

浅克隆（shallow clone），浅克隆是指拷贝对象时仅仅copy对象本身和对象中的基本变量，
而不拷贝对象包含的引用指向的对象。

深克隆（deep clone），不仅copy对象本身，而且copy对象包含的引用指向的所有对象。
举例：对象X中包含对Y的引用，Y中包含对Z的引用。浅拷贝X得到X1，X1中依然包含对Y的引用，
Y中依然包含对Z的引用。深拷贝则是对浅拷贝的递归，深拷贝X得到X1，X1中包含对Y1（Y的copy）的引用，
Y1中包含对Z1（Z的copy）的引用。


3. 克隆代码举例
要让对象可以被克隆，应具备以下2个条件：

让该类实现java.lang.Cloneable接口；
重写（Override）Object的clone()方法；





为什么需要克隆？

    在实际编程过程中，会需要创建与已经存在的对象A的值一样的对象B，但是是与A完全独立的一个对象，即对两个对象做修改互不影响，这时需要用克隆来创建对象B。通过new一个对象，然后各个属性赋值，也能实现该需求，但是clone方法是native方法，native方法的效率一般远高于非native方法（待了解）。

浅克隆

    对于Object类中的clone()方法产生的效果是：现在内存中开辟一块和原始对象一样的内存空间，然后原样拷贝原始对象中的内容。对基本数据类型来说，这样的操作不会有问题，但是对于非基本类型的变量，保存的仅仅是对象的引用，导致clone后的非基本类型变量和原始对象中相应的变量指向的是同一个对象，对非基本类型的变量的操作会相互影响。

结论：

1、克隆一个对象不会调用对象的构造方法。

2、clone()方法有三条规则：1）x.clone() != x; 2)x.clone().getClass() == x.getClass(); 3)一般情况下x.clone().equals(x); 3）不是必须要满足的。

3、对对象基本数据类型的修改不会互相影响，浅克隆对对象非基本数据类型的修改会相互影响，所以需要实现深克隆。

深克隆

    深克隆除了克隆自身对象，还对其非基本数据类型的成员变量克隆一遍。

深克隆的步骤：

1、首先克隆的类要实现Cloneable接口和重写Object的clone()方法。

2、在不引入第三方jar包的情况下，可以使用两种方法：1）先对对象进行序列化，紧接着马上反序列化 2）先调用super.clone()方法克隆出一个新对象，然后手动给克隆出来的对象的非基本数据类型的成员变量赋值。

    在数据结构比较复杂的情况下，序列化和反序列化可能实现起来简单，方法2）实现比较复杂。经测试2）会比1）的执行效率高。
